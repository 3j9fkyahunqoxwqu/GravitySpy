#!/usr/bin/env python

# Goal of this function is to complete the following work flow
# 1) Get some Omicron triggers (source: ~detchar/triggers XML)
# 2) Get ANALYSIS_READY segments from the segdb
# 3) Filter 1 to take out anything that is not in 2.
# 4) Filter 3 to only include triggers with SNR>6 and 10<=freq<2048.  
# 5) Write some new Omicron XML files (or even text files or HDF5 files) that contain the triggers that were in ANALYSIS_READY and have SNR>6. 
# 6) Create Omega Scans of the remaining omicron triggers

# -------------------------------------------------------------------------
#      Setup.
# -------------------------------------------------------------------------

# ---- Import standard modules to the python path.
from gwpy.table.lsctables import SnglBurstTable
from gwpy.segments import DataQualityFlag
import os,time, optparse, csv,sys,pickle,shlex,subprocess

###############################################################################
##########################                             ########################
##########################   Func: parse_commandline   ########################
##########################                             ########################
###############################################################################
# Definite Command line arguments here

def parse_commandline():
    """
    Parse the options given on the command-line.
    """
    parser = optparse.OptionParser()
    parser.add_option("--boxtime", help="Different time ranges (1 would represent +-0.5 around central time) for displaying the glitch) For Example: '[0.5 1 4 16]' would give you four differnt images with those different times boxes [Default:[0.5,1,2,4]",
                        default=[0.5,1,2,4])
    parser.add_option("--channelname", help="channel name [Default:GDS-CALIB_STRAIN]",
                        default="GDS-CALIB_STRAIN")
    parser.add_option("--colorMap", help="What color would you like the omegascans to be? [Default: jet] [Options: bone, copper,hot]", default="jet")
    parser.add_option("--detector", help="detector name [L1 or H1]. [No Default must supply]")
    parser.add_option("--gpsStart", help="gps Start Time of Query for meta data and omega scans. [No Default must supply]")
    parser.add_option("--gpsEnd", help="gps End Time [No Default must supply]")
    parser.add_option("--freqHigh", help="upper frequency bound cut off for the glitches. [Default: 2048]",type=int,default=2048)
    parser.add_option("--freqLow", help="lower frequency bound cut off for the glitches. [Default: 10]",type=int,default=10)
    parser.add_option("--ID", help="Filename of UniqueIDs you would like to make images for (generally done if desiring to see same image but in a different way.",default='somethingthatcantbefile.txt')
    parser.add_option("--imagepath", help="path to directory for images NO matter what path you select {detectorname}_{gpsStart}_{gpsEnd} will be added as a subdirectory [Default ~/public_html/GravitySpy/]",
                        default='~/public_html/GravitySpy/')
    parser.add_option("--nds2name", help="ip address or URL of the nds2\
                        server to use [Default: nds.ligo.caltech.edu]",
                        default="nds.ligo.caltech.edu")
    parser.add_option("--normalizedSNR", help="SNR Normalization value. [Default: 25.5]",type=float,default=25.5)
    parser.add_option("--maxSNR", help="This flag gives you the option to supply a upper limit to the SNR of the glitches [Default: 0 (i.e. none)]",type=float,default=0)
    parser.add_option("--outpath", help="path to output directory [Default: ./png] (This is where the images are created but you will not have to go in this folder as the iamges are transferred to your public_html imagepath folder)",
                        default=os.getcwd() + '/png')
    parser.add_option("--runlocal", help="run locally (running as a condor job has not been set up yet)",type=int,default=1)
    parser.add_option("--sampfrequency", help="sample frequency for omegascan iamges [Default: 4096]", type=int,default=4096)
    parser.add_option("--SNR", help="Lower bound SNR Threshold for omicron triggers, by default there is no upperbound SNR unless supplied throught the --maxSNR flag. [Default: 6]",type=float,default=6)
    parser.add_option("--verbose", action="store_true", default=False,
                      help="Run verbosely. (Default: False)")

    opts, args = parser.parse_args()

    return opts

###############################################################################
##########################                              #######################
##########################   Func: snr_freq_threshold   #######################
##########################                              #######################
###############################################################################
# Define snr_freq_threshold function that will filter omicron triggers based on SNR and frequency threshold the user sets (or the defaults.)

def snr_freq_threshold(row):
    if (opts.maxSNR == 0):
    	if (row.snr >= opts.SNR) and (row.peak_frequency <= opts.freqHigh) and (row.peak_frequency >= opts.freqLow):
    	    passthresh = True
    	else:
    	    passthresh = False
    	return passthresh
    else:
        if (row.snr >= opts.SNR) and (row.snr <= opts.maxSNR) and (row.peak_frequency <= opts.freqHigh) and (row.peak_frequency >= opts.freqLow):
            passthresh = True
        else:
            passthresh = False
        return passthresh

###############################################################################
##########################                          ###########################
##########################   Func: make_images_ID   ###########################
##########################                          ###########################
###############################################################################

# Define a function to make images if someone has already supplied IDs
def make_images_ID(centraltime,nds2name,detchannelname,outpath,imagepathname,normalizedSNR,boxtime,verbose,imagepath,sampfrequency,colorMap,ID):

    uniqueid = ID
    # Make temporary directory to create the images in
    system_call = 'mktemp -d {0}/AAA.XXXXXXXXXX'.format(outpath)
    os.system(system_call)
    tempname = os.listdir("{0}/".format(outpath))
    tempdir = ('{0}/'.format(outpath) + tempname[0])

    start1 = time.time()
    system_call = "dmt_wplot \
        frameCacheFile='data.cache' \
        frameType={0}_HOFT_C00 \
        ndsServer={1} \
        channelName={2} \
        eventTime={3} \
        outputDirectory={4} \
        plotType=spectrogram_whitened \
        plotTimeRanges='{5}' \
        sampleFrequency={6} \
        colorMap={7} \
        plotFrequencyRange='[10 inf]' \
        plotNormalizedEnergyRange='[0.0 {8}]'  \
        searchTimeRange=64 \
        searchFrequencyRange='[0 inf]' \
        searchQRange='[4.0 64.0]'\n".format(opts.detector,nds2name,detchannelname,centraltime,tempdir,boxtime,sampfrequency,colorMap,normalizedSNR)

    if verbose == True:
        print(system_call)

    os.system(system_call)
    end1 = time.time()
    print(end1-start1)

    os.chdir('{0}'.format(tempdir))

    pngnames = os.listdir('./')
    if verbose == True:
        print(pngnames)

    # If image is not created server must be down. Exit fucntion
    if len(pngnames) ==1:
        print "OH NO! Script failed starting at GPS time {0}".format(centraltime)
        # write file to indicate at what GPStime the image generation failed.
        sys.exit()

    for iTime in xrange(0,len(boxtime)):

        system_call = 'convert *{0}_{1}* -chop 0x35 {2}/{3}_{4}_{5}.png'.format(detchannelname,boxtime[iTime],outpath,opts.detector,uniqueid,boxtime[iTime])
        os.system(system_call)

    # Back out of temp directory and delete it
    os.chdir('..')
    system_call = 'rm -rf {0}/'.format(tempdir)
    os.system(system_call)

    # Copy converted image to public_html and back out of png directory and delete duplicate .png inside of folder.

    system_call = 'cp {0}/{1}_{2}*.png {3}'.format(outpath,opts.detector,uniqueid,imagepath)
    os.system(system_call)

    os.chdir('..')
    system_call = 'rm -rf {0}/*'.format(outpath)
    os.system(system_call)


###############################################################################
##########################                          ###########################
##########################   Func: make_images      ###########################
##########################                          ###########################
###############################################################################

# This takes in information from omicron triggers and generates images and IDs (this function is for running locally.)
def make_images(centraltime,nds2name,detchannelname,outpath,imagepathname,normalizedSNR,boxtime,verbose,imagepath,sampfrequency,colorMap):

    # Make temporary directory to create the images in
    system_call = 'mktemp -d {0}/AAA.XXXXXXXXXX'.format(outpath)
    os.system(system_call)
    
    tempname = os.listdir("{0}/".format(outpath))
    tempdir = ('{0}/'.format(outpath) + tempname[0])
    uniqueid = tempname[0].split('.')[1]
    print('unique id is {0}'.format(uniqueid))

    # Use random folder name as I.D. Tag but first check if this gps time 
    # already has a I.D. tag and use that if it does.
    idfile =  open('ID.txt', "a+")
    idfile.write('{0} {1} {2}\n'.format(detchannelname,centraltime,uniqueid))
    idfile.close()
    # Open file for writing metadata for images
    metadata =  open(imagepath + '/imagemetadata.txt', "a+")

    start1 = time.time()
    system_call = "dmt_wplot \
	frameCacheFile='data.cache' \
        frameType={0}_HOFT_C00 \
        ndsServer={1} \
        channelName={2} \
        eventTime={3} \
        outputDirectory={4} \
        plotType=spectrogram_whitened \
        plotTimeRanges='{5}' \
        sampleFrequency={6} \
        colorMap={7} \
        plotFrequencyRange='[10 inf]' \
        plotNormalizedEnergyRange='[0.0 {8}]'  \
        searchTimeRange=64 \
        searchFrequencyRange='[0 inf]' \
        searchQRange='[4.0 64.0]'\n".format(opts.detector,nds2name,detchannelname,centraltime,tempdir,boxtime,sampfrequency,colorMap,normalizedSNR)

    if verbose == True:
	print(system_call)

    os.system(system_call)
    end1 = time.time()
    print(end1-start1)

    os.chdir('{0}'.format(tempdir))

    pngnames = os.listdir('./')
    if verbose == True:
	print(pngnames)

    # If image is not created server must be down. Exit fucntion
    if len(pngnames) ==1:
	print "OH NO! Script failed starting at GPS time {0}".format(centraltime)
	# write file to indicate at what GPStime the image generation failed.
	sys.exit()

    for iTime in xrange(0,len(boxtime)):

        system_call = 'convert *{0}_{1}* -chop 0x35 {2}/{3}_{4}_{5}.png'.format(detchannelname,boxtime[iTime],outpath,opts.detector,uniqueid,boxtime[iTime])
        os.system(system_call)

    # Create .csv to upload metadata of images to the project builder
    metadata.write('{0} 20151016 {1}_{2}_{3}.png {4}_{5}_{6}.png {7}_{8}_{9}.png {10}_{11}_{12}.png\n'.format(uniqueid,opts.detector,uniqueid,boxtime[0],opts.detector,uniqueid,boxtime[1],opts.detector,uniqueid,boxtime[2],opts.detector,uniqueid,boxtime[3]))
    metadata.close()

    # Back out of temp directory and delete it
    os.chdir('..')
    system_call = 'rm -rf {0}/'.format(tempdir)
    os.system(system_call)

    # Copy converted image to public_html and back out of png directory and delete duplicate .png inside of folder.

    system_call = 'cp {0}/{1}_{2}*.png {3}'.format(outpath,opts.detector,uniqueid,imagepath)
    os.system(system_call)

    os.chdir('..')
    system_call = 'rm -rf {0}/*'.format(outpath)
    os.system(system_call)

    return uniqueid

###############################################################################
##########################                          ###########################
##########################   Func: verbosity        ###########################
##########################                          ###########################
###############################################################################

# Function to spit out useful verbosity whether generating a submission file or running locally.

def verbosity(detchannelname):

    # Let the user know what detector and channel combo they have selected.
    print "You have selected detector channel combination {0}".format(detchannelname)

    # Let the user know which SNR cut they have selected.
    print "You have selected a SNR cut of {0}".format(opts.SNR)

    # Let the user know which SNR normalization max they have selected.
    print "You have selected a SNR normalization max of {0}".format(opts.normalizedSNR)

    # Let the user know which colormpa color they have  selected.
    print "You have selected a colormap color of {0}".format(opts.colorMap)

    # Where will the images be generated
    print('Images will be made:' + opts.outpath)

    # Where will the final images end up
    print('Path to directory where final images will appear:' + imagepathname)

###############################################################################
##########################                          ###########################
##########################   Func: get_triggers     ###########################
##########################                          ###########################
###############################################################################

# This function queries omicron to obtain trigger times of the glitches. It then proceeds to filter out these times based on whether the detector was in an analysis ready state or the glitch passes certain frequency and SNR cuts. 

def get_triggers(detchannelname):

    # Obtain segments from L1 that are analysis ready
    analysis_ready = DataQualityFlag.query('{0}:DMT-ANALYSIS_READY:1'.format(opts.detector),opts.gpsStart,opts.gpsEnd)

    # Display segments for which this flag is true
    print "Segments for which the ANALYSIS READY Flag is active: {0}".format(analysis_ready.active)

    # Fetch raw omicron triggers and apply filter which is defined in a function above.
    omicrontriggers = SnglBurstTable.fetch(detchannelname,'Omicron',\
    opts.gpsStart,opts.gpsEnd,filt=snr_freq_threshold)

    print "List of available metadata information for a given glitch provided by omicron: {0}".format(omicrontriggers.columnnames)

    print "Number of triggers after SNR and Freq cuts but before ANALYSIS READY flag filtering: {0}".format(len(omicrontriggers))

    # Filter the raw omicron triggers against the ANALYSIS READY flag.
    omicrontriggers = omicrontriggers.vetoed(analysis_ready.active)

    print "Final trigger length: {0}".format(len(omicrontriggers))

    return omicrontriggers

###############################################################################
##########################                            #########################
##########################   Func: call_data_find     #########################
##########################                            #########################
###############################################################################

# Call gw_data_find in order to create a cache file to be parsed by dmt_wplot. This is significantly faster way to get images generated then going through the NDS2 server.

def call_data_find(detstrip):

    system_call = 'gw_data_find --observatory={0} -s {1} -e {2} --type={3}_HOFT_C00  -W > data.cache'.format(detstrip,opts.gpsStart,opts.gpsEnd,opts.detector)
    print('Cache file generated by the following: {0}'.format(system_call))
    os.system(system_call)

###############################################################################
##########################                            #########################
##########################   Func: write_sub_file     #########################
##########################                            #########################
###############################################################################

# Write submission file for the condor job

def write_subfile():
    with open('gravityspy.sub', 'w') as subfile:
    	subfile.write('universe = vanilla\n')
        subfile.write('executable = /home/scoughlin/detchar/GlitchZoo/GravitySpy/read_omicron_triggers\n')
	subfile.write('\n')
        subfile.write('arguments = "--gpsStart {0} --gpsEnd {1} --detector {2} --runlocal 2 --verbose"\n'.format(opts.gpsStart,opts.gpsEnd,opts.detector))
        subfile.write('getEnv=True\n')
	subfile.write('\n')
        subfile.write('accounting_group_user = scott.coughlin\n')
        subfile.write('accounting_group = ligo.dev.o1.detchar.ch_categorization.glitchzoo\n')
	subfile.write('\n')
        subfile.write('priority = 0\n')
        subfile.write('request_memory = 1000\n')
	subfile.write('\n')
        subfile.write('error = logs/gravityspy-$(cluster)-$(process).err\n')
        subfile.write('output = logs/gravityspy-$(cluster)-$(process).out\n')
        subfile.write('notification = never\n')
        subfile.write('queue 1')

###############################################################################
##########################                     ################################
##########################      MAIN CODE      ################################
##########################                     ################################
###############################################################################

# Parse commandline arguments

opts = parse_commandline()

# Create some variable and file directories based on inputs

# Take the detector and the channel from the command line and combine them into one string. This is needed for some input later on.
detchannelname = opts.detector + ':' +  opts.channelname

# Need to strip the 1 away from detector name
detstrip = opts.detector.split('1')[0]

# Create a string of detector name, gpsStart and gpsEnd time that will be used repeatedly throughout code

detGPSstr = opts.detector + '_'  + str(opts.gpsStart) + '_' + str(opts.gpsEnd)

# Take imagepath add a directory indicating the detector and the gpsStart and gpsEnd times

imagepathname = os.path.expanduser(opts.imagepath) + '/' + detGPSstr + '/'
system_call = 'mkdir -p ' + imagepathname
os.system(system_call)

# create a path where the images will get generated

system_call = 'mkdir -p ' + opts.outpath
os.system(system_call)

# Create the path to the glitch metadata
system_call = 'mkdir -p glitchmetadata'
os.system(system_call)

# open a txt file where the image metadata for consumption by the Zooniverse servers will be stored.
metadata =  open(imagepathname + '/imagemetadata.txt', "w+")
metadata.write('ID Date Filename1 Filename2 Filename3 Filename4\n')
metadata.close()

# Open metadata file for GLITCH metadata information
glitchmetadata = open('./glitchmetadata/' + detGPSstr + '.txt',"w+")
# Headers indicating the metadata WE have selected as of right now.
# SNR, Amplitude, peak_freq, cent_freq, duration, bandwidth, UniqueID
glitchmetadata.write('# SNR, Amplitude, peak_freq, cent_freq, duration, bandwidth, UniqueID\n')
glitchmetadata.close()

# open Id.txt which will store the link between GPS time and Randomly Generated Unqiue ID of an image
# if there is already an Id.txt file, just append the new IDs to it
if os.path.isfile('ID.txt')==False:
        idfile =  open('ID.txt', "w+")
        idfile.write('# Channel GPSTime UniqueID\n')
        idfile.close()
else:
        idfile =  open('ID.txt', "a+")
        idfile.close()

# Depending on if you are running locally or not. If not running local, then the code will create a condor .dag file and a .sub file in order to submit to the cluster. (In Beta)

if int(opts.runlocal) == 1:

	print('Did you remember to run kinit albert.einstein@LIGO.ORG?')
	# Need to establish ligo-proxy.
	system_call = 'ligo-proxy-init -k'
	os.system(system_call)
	# Provide some information about settings the user provided 
	# or the default settings
	verbosity(detchannelname)
	# Obtain the omicron triggers used to generated the images
	omicrontriggers = get_triggers(detchannelname)
	# Create a cache file indicating what data frames these 
	# images can be found in.
	call_data_find(detstrip)

elif int(opts.runlocal) == 0:

	# Need to establish ligo-proxy in order to generate triggers 
	# and data.cache before running the condor job.
	system_call = 'ligo-proxy-init -k'
	os.system(system_call)
        # Provide some information about settings the user provided 
        # or the default settings
        verbosity(detchannelname)
        # Obtain the omicron triggers used to generated the images
        omicrontriggers = get_triggers(detchannelname)
        # Create a cache file indicating what data frames these 
        # images can be found in.
        call_data_find(detstrip)
        # need to save omicron triggers variable to be loaded by the condor job later
	filename = open("triggers.xml",'w')
	omicrontriggers.write(fileobj=filename)

	# Make a logs file directory and create condor subfile
	system_call = 'mkdir -p logs'
	os.system(system_call)
	write_subfile()
	sys.exit(1)

else:
	print("running on condor")
	omicrontriggers = SnglBurstTable.read('triggers.xml')

# Check to see if set of UniqueIDs has been supplied. If yes then we will bypass
# part of the script.
if os.path.isfile(opts.ID)==True:
        IDfile = open(opts.ID,'r')
        IDinput = IDfile.read().splitlines()
        for rows in xrange(0,len(IDinput)):
                commandline = 'grep "{0}" ID.txt'.format(IDinput[rows])
		proc = subprocess.Popen(shlex.split(commandline), stdout=subprocess.PIPE)
		output = proc.stdout.read()
		output = output.split(detchannelname)[1]
		ctime   = output.split(' ')[1]
		
		make_images_ID(ctime,opts.nds2name,detchannelname,opts.outpath,imagepathname,opts.normalizedSNR,opts.boxtime,opts.verbose,imagepathname,opts.sampfrequency,opts.colorMap,IDinput[rows])
        print >> sys.stderr, "OK now what"
        sys.exit(1)

for omicrontrigger in omicrontriggers:
    start=time.time()
    # Run the function make_images which will generate the iamge and create an uniqueID to assign to that image
    uniqueid = make_images('{0}.{1}'.format(omicrontrigger.peak_time,omicrontrigger.peak_time_ns),opts.nds2name,detchannelname,opts.outpath,imagepathname,opts.normalizedSNR,opts.boxtime,opts.verbose,imagepathname,opts.sampfrequency,opts.colorMap)
    # For this trigger write all the metadata of the trigger plus the unqiueID generated during make_images 
    with open('./glitchmetadata/' + detGPSstr + '.txt','a+') as f:
	f.write('{0} {1} {2} {3} {4} {5} {6}\n'.format(omicrontrigger.snr,omicrontrigger.amplitude,omicrontrigger.peak_frequency,omicrontrigger.central_freq,omicrontrigger.duration,omicrontrigger.bandwidth,uniqueid))
	f.close()
    end =time.time()
    print(end-start)

# House Cleaning

system_call = 'rm -rf {0}'.format(opts.outpath)
os.system(system_call)

# We must now convert image metadata to CSV to prep for upload.

txt_file = imagepathname  + '/imagemetadata.txt'
csv_file = imagepathname  + '/imagemetadata.csv'
in_txt = csv.reader(open(txt_file, "rb"), delimiter = ' ')
out_csv = csv.writer(open(csv_file, 'wb'))
out_csv.writerows(in_txt)
system_call = 'tar -czvf ' + imagepathname + '/' + detGPSstr + '.tar ' + imagepathname  + '/*.png'
os.system(system_call)

